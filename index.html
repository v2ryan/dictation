<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kids Dictation Buddy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #E0F7FA; /* Light Cyan */
            touch-action: manipulation; /* Improve touch response */
        }
        /* Custom slider styling for kid-friendly look */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #FF9800;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #B2EBF2;
            border-radius: 3px;
        }
        .btn-press:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-2xl bg-white rounded-3xl shadow-2xl overflow-hidden border-4 border-blue-200">
        
        <!-- Header -->
        <div class="bg-blue-400 p-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-white tracking-wide">üìù Dictation Buddy</h1>
        </div>

        <div class="p-6 space-y-6">

            <!-- Input Section -->
            <div id="setup-panel">
                <div class="flex justify-between items-center mb-2">
                    <label class="block text-xl text-gray-700 font-bold">1. Paste Words Here:</label>
                    <button id="btnCamera" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-xl text-sm font-bold flex items-center gap-2 shadow-sm transition-colors">
                        <span class="text-lg">üì∑</span> Scan Photo
                    </button>
                    <input type="file" id="cameraInput" accept="image/*" class="hidden">
                </div>
                <textarea id="wordInput" class="w-full h-32 p-4 border-2 border-blue-200 rounded-xl text-lg focus:outline-none focus:border-blue-400 transition-colors resize-none" placeholder="apple, banana, orange..."></textarea>
                <p class="text-sm text-gray-500 mt-1 text-right">Separate words with commas or new lines.</p>
            </div>

            <!-- Settings Section -->
            <div class="bg-yellow-50 p-4 rounded-2xl border-2 border-yellow-100">
                <h2 class="text-xl font-bold text-yellow-800 mb-4">‚öôÔ∏è Settings</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Language -->
                    <div>
                        <label class="block text-gray-700 font-bold mb-2">Language</label>
                        <select id="languageSelect" class="w-full p-3 bg-white border-2 border-yellow-200 rounded-xl text-lg focus:outline-none">
                            <option value="en-US">üá∫üá∏ English (US)</option>
                            <option value="zh-HK">üá≠üá∞ Cantonese (HK)</option>
                        </select>
                    </div>

                    <!-- Speed -->
                    <div>
                        <label class="block text-gray-700 font-bold mb-2">Reading Speed: <span id="speedValue" class="text-blue-500">1.0x</span></label>
                        <input type="range" id="rateRange" min="0.5" max="1.5" step="0.1" value="0.8">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>Slow</span>
                            <span>Fast</span>
                        </div>
                    </div>

                    <!-- Gap -->
                    <div class="md:col-span-2">
                        <label class="block text-gray-700 font-bold mb-2">Gap Between Words: <span id="gapValue" class="text-blue-500">3s</span></label>
                        <input type="range" id="gapRange" min="1" max="10" step="1" value="3">
                        <div class="flex justify-between text-xs text-gray-400 mt-1">
                            <span>1s</span>
                            <span>10s</span>
                        </div>
                    </div>

                    <!-- Options -->
                    <div class="md:col-span-2 bg-white p-3 rounded-xl border border-yellow-200">
                        <label class="flex items-center space-x-3 cursor-pointer">
                            <input type="checkbox" id="readPunctuation" class="w-6 h-6 text-blue-600 rounded focus:ring-blue-500 border-gray-300">
                            <span class="text-gray-700 font-bold text-lg">üó£Ô∏è Read Punctuation (ËÆÄÊ®ôÈªû)</span>
                        </label>
                        <p class="text-xs text-gray-500 mt-1 ml-9">Reads symbols like comma, period, etc. (Splits by newline only)</p>
                    </div>
                </div>
            </div>

            <!-- Active Display (Hidden by default) -->
            <div id="active-display" class="hidden py-8 text-center bg-blue-50 rounded-2xl border-2 border-blue-100">
                <p class="text-gray-500 text-xl mb-2">Word Number</p>
                <div class="text-6xl font-bold text-blue-600 mb-4">
                    <span id="currentWordIndex">0</span> / <span id="totalWords">0</span>
                </div>
                <div id="statusMessage" class="text-lg text-orange-500 font-semibold animate-pulse">
                    Get Ready...
                </div>
            </div>

            <!-- Controls -->
            <div class="grid grid-cols-3 gap-4 pt-2">
                <button id="btnStart" class="btn-press bg-green-400 hover:bg-green-500 text-white font-bold py-4 px-4 rounded-2xl shadow-md text-xl md:text-2xl transition-colors flex flex-col items-center justify-center">
                    <span class="text-3xl mb-1">‚ñ∂Ô∏è</span>
                    Start
                </button>
                
                <button id="btnPause" class="btn-press bg-yellow-400 hover:bg-yellow-500 text-white font-bold py-4 px-4 rounded-2xl shadow-md text-xl md:text-2xl transition-colors flex flex-col items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <span class="text-3xl mb-1">‚è∏Ô∏è</span>
                    Pause
                </button>
                
                <button id="btnStop" class="btn-press bg-red-400 hover:bg-red-500 text-white font-bold py-4 px-4 rounded-2xl shadow-md text-xl md:text-2xl transition-colors flex flex-col items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <span class="text-3xl mb-1">‚èπÔ∏è</span>
                    Stop
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- Variables ---
        const synth = window.speechSynthesis;
        let words = [];
        let currentIndex = 0;
        let isPaused = false;
        let isRunning = false;
        let timeoutId = null;
        
        // --- Elements ---
        const wordInput = document.getElementById('wordInput');
        const languageSelect = document.getElementById('languageSelect');
        const rateRange = document.getElementById('rateRange');
        const gapRange = document.getElementById('gapRange');
        const readPunctuation = document.getElementById('readPunctuation');
        const speedValue = document.getElementById('speedValue');
        const gapValue = document.getElementById('gapValue');
        
        const btnStart = document.getElementById('btnStart');
        const btnPause = document.getElementById('btnPause');
        const btnStop = document.getElementById('btnStop');
        const btnCamera = document.getElementById('btnCamera');
        const cameraInput = document.getElementById('cameraInput');
        
        const setupPanel = document.getElementById('setup-panel');
        const activeDisplay = document.getElementById('active-display');
        const currentWordIndexEl = document.getElementById('currentWordIndex');
        const totalWordsEl = document.getElementById('totalWords');
        const statusMessage = document.getElementById('statusMessage');

        // --- Initialization ---
        
        // Update slider labels
        rateRange.addEventListener('input', (e) => speedValue.textContent = e.target.value + 'x');
        gapRange.addEventListener('input', (e) => gapValue.textContent = e.target.value + 's');

        // Load voices (iOS fix: sometimes voices load asynchronously)
        let voices = [];
        function loadVoices() {
            voices = synth.getVoices();
        }
        loadVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }

        // --- Core Functions ---

        function parseWords() {
            const text = wordInput.value;
            
            if (readPunctuation.checked) {
                // If reading punctuation, we assume sentences/lines.
                // Split by newline only, keeping commas inside the text.
                return text.split(/\n+/).map(w => w.trim()).filter(w => w.length > 0);
            } else {
                // Standard mode: Split by newline or comma
                return text.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0);
            }
        }

        function getVoice(lang) {
            // Try to find a specific voice for the language
            // iOS often has "Samantha" for en-US and "Sin-ji" for zh-HK
            return voices.find(voice => voice.lang === lang) || null;
        }

        function processPunctuation(text, lang) {
            if (!readPunctuation.checked) return text;

            // Mapping for English
            if (lang.startsWith('en')) {
                return text
                    .replace(/\./g, ' full stop ')
                    .replace(/,/g, ' comma ')
                    .replace(/\?/g, ' question mark ')
                    .replace(/!/g, ' exclamation mark ')
                    .replace(/:/g, ' colon ')
                    .replace(/;/g, ' semi colon ')
                    .replace(/"/g, ' quote ')
                    .replace(/'/g, ' apostrophe ');
            } 
            // Mapping for Chinese (Cantonese)
            else if (lang.startsWith('zh')) {
                return text
                    .replace(/„ÄÇ/g, ' Âè•Ëôü ')
                    .replace(/Ôºå/g, ' ÈÄóËôü ')
                    .replace(/Ôºü/g, ' ÂïèËôü ')
                    .replace(/ÔºÅ/g, ' ÊÑüÂòÜËôü ')
                    .replace(/Ôºö/g, ' ÂÜíËôü ')
                    .replace(/Ôºõ/g, ' ÂàÜËôü ')
                    .replace(/„Äå/g, ' ‰∏äÂºïËôü ')
                    .replace(/„Äç/g, ' ‰∏ãÂºïËôü ')
                    .replace(/„ÄÅ/g, ' È†ìËôü ')
                    .replace(/\./g, ' Èªû ')
                    .replace(/,/g, ' ÈÄóËôü ');
            }
            return text;
        }

        function speak(text, callback) {
            if (synth.speaking) {
                console.error('speechSynthesis.speaking');
                return;
            }
            
            const selectedLang = languageSelect.value;
            
            // Process text for punctuation reading if enabled
            const textToSpeak = processPunctuation(text, selectedLang);

            const utterThis = new SpeechSynthesisUtterance(textToSpeak);
            
            utterThis.lang = selectedLang;
            utterThis.rate = parseFloat(rateRange.value);
            
            // Attempt to set a specific voice object if available
            const voice = getVoice(selectedLang);
            if (voice) {
                utterThis.voice = voice;
            }

            utterThis.onend = function (event) {
                if (callback) callback();
            };

            utterThis.onerror = function (event) {
                console.error('SpeechSynthesisUtterance.onerror', event);
                if (callback) callback(); // Proceed even if error
            };

            synth.speak(utterThis);
        }

        function nextStep() {
            if (!isRunning) return;
            if (isPaused) return;

            if (currentIndex >= words.length) {
                finishDictation();
                return;
            }

            // Update UI
            currentWordIndexEl.textContent = currentIndex + 1;
            statusMessage.textContent = "Reading...";
            statusMessage.className = "text-lg text-green-500 font-bold";

            const word = words[currentIndex];
            
            // Speak the word
            speak(word, () => {
                // After speaking, wait for the gap
                if (!isRunning) return; // Check again in case stopped during speech
                
                statusMessage.textContent = "Waiting...";
                statusMessage.className = "text-lg text-blue-400 font-semibold animate-pulse";
                
                const gapTime = parseInt(gapRange.value) * 1000;
                
                timeoutId = setTimeout(() => {
                    currentIndex++;
                    nextStep();
                }, gapTime);
            });
        }

        function startDictation() {
            const parsedWords = parseWords();
            if (parsedWords.length === 0) {
                alert("Please enter some words first!");
                return;
            }

            // Reset State
            words = parsedWords;
            currentIndex = 0;
            isRunning = true;
            isPaused = false;

            // Update UI
            setupPanel.classList.add('hidden');
            activeDisplay.classList.remove('hidden');
            totalWordsEl.textContent = words.length;
            
            btnStart.disabled = true;
            btnStart.classList.add('opacity-50', 'cursor-not-allowed');
            btnPause.disabled = false;
            btnPause.classList.remove('opacity-50', 'cursor-not-allowed');
            btnStop.disabled = false;
            btnStop.classList.remove('opacity-50', 'cursor-not-allowed');

            // Start loop
            nextStep();
        }

        function pauseDictation() {
            if (!isRunning) return;

            if (isPaused) {
                // Resume
                isPaused = false;
                btnPause.innerHTML = '<span class="text-3xl mb-1">‚è∏Ô∏è</span>Pause';
                btnPause.classList.remove('bg-orange-400', 'hover:bg-orange-500');
                btnPause.classList.add('bg-yellow-400', 'hover:bg-yellow-500');
                
                // If we were in a timeout gap, we need to resume immediately or after remaining time?
                // Simplification: Just call nextStep immediately to move to next word or re-read current?
                // Better UX: If we paused during a gap, just move to next word immediately.
                // If we paused during speech, speech synthesis handles resume usually, but here we are managing flow manually.
                // Since we can't easily "resume" a setTimeout, we will just proceed to the next step logic.
                // However, if synth was paused, we resume it.
                
                if (synth.paused) {
                    synth.resume();
                } else {
                    // If not speaking, we were likely in a gap.
                    // Let's just trigger next step immediately for simplicity
                    nextStep();
                }

            } else {
                // Pause
                isPaused = true;
                clearTimeout(timeoutId);
                synth.pause(); // Pause current speech if any
                
                btnPause.innerHTML = '<span class="text-3xl mb-1">‚ñ∂Ô∏è</span>Resume';
                btnPause.classList.remove('bg-yellow-400', 'hover:bg-yellow-500');
                btnPause.classList.add('bg-orange-400', 'hover:bg-orange-500');
                statusMessage.textContent = "Paused";
                statusMessage.className = "text-lg text-orange-500 font-bold";
            }
        }

        function stopDictation() {
            isRunning = false;
            isPaused = false;
            clearTimeout(timeoutId);
            synth.cancel();

            // Reset UI
            setupPanel.classList.remove('hidden');
            activeDisplay.classList.add('hidden');
            
            btnStart.disabled = false;
            btnStart.classList.remove('opacity-50', 'cursor-not-allowed');
            
            btnPause.disabled = true;
            btnPause.classList.add('opacity-50', 'cursor-not-allowed');
            btnPause.innerHTML = '<span class="text-3xl mb-1">‚è∏Ô∏è</span>Pause';
            btnPause.classList.remove('bg-orange-400', 'hover:bg-orange-500');
            btnPause.classList.add('bg-yellow-400', 'hover:bg-yellow-500');

            btnStop.disabled = true;
            btnStop.classList.add('opacity-50', 'cursor-not-allowed');
        }

        function finishDictation() {
            stopDictation();
            alert("Dictation Complete! Great job! üéâ");
        }

        // --- Event Listeners ---
        btnStart.addEventListener('click', startDictation);
        btnPause.addEventListener('click', pauseDictation);
        btnStop.addEventListener('click', stopDictation);

        // iOS Safari quirk: Speech synthesis must be triggered by user interaction first.
        // We can play a silent utterance on the first touch of the page to "unlock" it.
        document.body.addEventListener('touchstart', function() {
            if (synth.getVoices().length === 0) {
                synth.getVoices();
            }
        }, { once: true });

        // --- OCR Functionality ---
        btnCamera.addEventListener('click', () => {
            cameraInput.click();
        });

        cameraInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // UI Loading State
            const originalBtnContent = btnCamera.innerHTML;
            btnCamera.innerHTML = '<span class="animate-spin">‚è≥</span> Scanning...';
            btnCamera.disabled = true;
            btnCamera.classList.add('opacity-75', 'cursor-wait');

            try {
                // Initialize worker with English and Traditional Chinese
                const worker = await Tesseract.createWorker('eng+chi_tra');
                
                const ret = await worker.recognize(file);
                await worker.terminate();
                
                let text = ret.data.text;
                
                // Cleanup Text
                // 1. Remove pipes, brackets which are common OCR errors for table lines
                // 2. Fix Chinese spacing (remove spaces between Chinese characters)
                // 3. Collapse multiple spaces
                // 4. Remove double commas
                
                text = text.replace(/[|\[\]{}]/g, ' ')
                           // Remove spaces between Chinese characters (range \u4e00-\u9fa5)
                           .replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2')
                           .replace(/\s+/g, ' ') // Collapse spaces
                           .replace(/,\s*,/g, ',') // Remove double commas
                           .trim();

                // Append to existing text
                const currentText = wordInput.value.trim();
                if (currentText.length > 0) {
                    // If current text doesn't end with newline, add one
                    wordInput.value = currentText + '\n' + text;
                } else {
                    wordInput.value = text;
                }
                
            } catch (err) {
                console.error("OCR Error:", err);
                alert("Oops! Could not read the text. Please try again with a clearer photo.");
            } finally {
                // Reset UI
                btnCamera.innerHTML = originalBtnContent;
                btnCamera.disabled = false;
                btnCamera.classList.remove('opacity-75', 'cursor-wait');
                cameraInput.value = ''; // Allow selecting same file again
            }
        });

    </script>
</body>
</html>
